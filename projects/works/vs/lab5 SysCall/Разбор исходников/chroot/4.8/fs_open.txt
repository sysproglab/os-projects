SYSCALL_DEFINE1(chroot, const char __user *, filename)
{
	struct path path;
	int error;
	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
retry:
    //получить путь к новой папке
	error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
    //Если ошибка выйти
	if (error)
		goto out;

    //Проверить права доступа к данному inode
	error = inode_permission(path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);
	if (error)
		goto dput_and_out;

	error = -EPERM;
    //Определите, является ли текущая задача выполнимой
    //в текущем пространстве имен пользователя
	if (!ns_capable(current_user_ns(), CAP_SYS_CHROOT))
		goto dput_and_out;
    //Проверка безопасной замены дирректории
	error = security_path_chroot(&path);
	if (error)
		goto dput_and_out;

    //Заменяет fs->{rootmnt,root} на {mnt,dentry}(новые).
	set_fs_root(current->fs, &path);
	error = 0;
dput_and_out:
	path_put(&path);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
out:
	return error;
}